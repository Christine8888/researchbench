{
    "task_id": "stellar_obliquity_inference",
    "kind": "numeric",
    "difficulty": 5,
    "paper_id": "stellar_obliquity",
    "description": "Implement the full hierarchical Bayesian framework to infer stellar obliquity from sky-projected measurements",
    "instructions": [
        "1. Set random seed to 42 for reproducibility using numpy.random.seed(42).",
        "2. Generate a dataset of 100 systems by creating cos $\\psi$ values from a mixture distribution where 70% of systems have cos $\\psi$ ~ Beta(14, 0.6) and 30% have cos $\\psi$ ~ Beta(2, 2).",
        "3. For the Beta(14, 0.6) component, generate samples from Beta distribution and map from [0,1] to [-1,1] using the transformation: cos $\\psi$ = 2u - 1, where u is the Beta sample.",
        "4. For the Beta(2, 2) component, apply the same mapping transformation: cos $\\psi$ = 2u - 1.",
        "5. For each system, generate a random azimuthal angle $\\theta$ from a uniform distribution between 0 and $\\pi$ using numpy.random.uniform(0, np.pi, size=100).",
        "6. Set orbital inclination $i_{\\text{orb}} = 90\u00b0$ for all systems as typical for transiting planets.",
        "7. Calculate the corresponding sky-projected stellar obliquity $\\lambda$ using the equation from \\ref{sec:coords}: $\\lambda = \\tan^{-1}\\left(\\frac{\\sin \\psi \\sin \\theta}{-\\sin \\psi \\cos \\theta \\cos i_{\\text{orb}} + \\cos \\psi \\sin i_{\\text{orb}}}\\right)$.",
        "8. Since $i_{\\text{orb}} = 90\u00b0$, simplify the equation to: $\\lambda = \\tan^{-1}\\left(\\frac{\\sin \\psi \\sin \\theta}{\\cos \\psi}\\right)$.",
        "9. Use numpy.arctan2 to handle quadrant determination correctly: $\\lambda$ = numpy.arctan2(sin($\\psi$) * sin($\\theta$), cos($\\psi$)).",
        "10. Add Gaussian noise with $\\sigma = 8\u00b0$ to the generated $\\lambda$ values using numpy.random.normal(0, 8, size=100).",
        "11. Convert all angle measurements to radians for computation, then back to degrees for noise addition.",
        "12. Implement the hierarchical Bayesian framework using PyMC following the methodology in \\ref{sec:hbm}.",
        "13. Set up a two-component Beta mixture model for cos $\\psi$ with hyperparameters $\\bm{\\beta} = \\{\\bm{w}, \\bm{\\mu}, \\bm{\\kappa}\\}$ as described in \\ref{sec:hbm}.",
        "14. Use the priors specified in \\ref{sec:hbm}: $\\mu_{0,1} \\sim \\mathcal{U}(0, 1)$ and $\\log \\kappa_{0,1} \\sim \\mathcal{N}(0, 3)$.",
        "15. Run MCMC sampling with 4 chains, 1000 tuning samples, and 2000 samples per chain using PyMC's NUTS sampler.",
        "16. Extract the posterior samples for the weight $w_1$ of the first component representing aligned systems.",
        "17. Calculate the posterior mean of $w_1$ and round to 2 decimal places.",
        "18. Verify that the computation completes in less than 10 minutes on a standard laptop with multicore processor.",
        "19. Return the posterior mean of $w_1$ rounded to 2 decimal places as the final result."
    ],
    "expected_output": 0.7,
    "tolerance": 0.3,
    "parents": [],
    "output_justification": "This task tests the full Bayesian framework from the paper with a hypothetical scenario. The expected output is the true value of w\u2081 used to generate the data, with a tolerance that accounts for the complexity of inference and sampling variability."
}